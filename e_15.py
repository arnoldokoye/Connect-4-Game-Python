# -*- coding: utf-8 -*-
"""E.15

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MMxclF8zvW9_a9ZDnIIWqPQI8QKBJYWo
"""

def render(board: list[list[str]], winner: set[tuple[int, int]] | None) -> None:
    """Renders the game board to the console.

    ----------------------------------------------------------------------------

    ## The Board

    The `board` must be a list with as many rows as the final, square rendered
    output should be. It must also be in column-major order, meaning that each
    row in the list represents a column in the rendered output. For example, a
    list that looks like this:

    ```python
    board = [
        ["X", "X"],
        ["X", "O", "X"],
        ["O"],
        [],
        ["O"],
    ]
    ```

    Would map to an output that looks like this:
    ```text
        +---+---+---+---+---+
        |   |   |   |   |   |
        +---+---+---+---+---+
        |   |   |   |   |   |
        +---+---+---+---+---+
        |   | X |   |   |   |
        +---+---+---+---+---+
        | X | O |   |   |   |
        +---+---+---+---+---+
        | X | X | O |   | O |
        +---+---+---+---+---+
    ```

    The board can be a jagged list, with missing entries assumed to be blank.

    Each token in the board should be a single character wide; e.g. length = 1.

    ----------------------------------------------------------------------------

    ## Winning Cells

    When a winner has been found, you can pass in a set of (row, column) pairs
    indicating which of cells should be rendered with emphasis to highlight the
    winner. The `row` and `column` pairs should refer to the row and column of
    the list, **not** the final rendered product.

    As an example, if player one won with this board:

    ```text
        +---+---+---+---+---+
        |   |   |   |   |   |
        +---+---+---+---+---+
        |   |   |   | X |   |
        +---+---+---+---+---+
        |   |   | X | O |   |
        +---+---+---+---+---+
        |   | X | X | O |   |
        +---+---+---+---+---+
        | X | O | O | O | X |
        +---+---+---+---+---+
    ```

    We could highlight the winning cells using a set with the following values:

    ```python
    winner = { (0, 0), (1, 1), (2, 2), (3, 3) }
    ```

    This would produce a board that looks as follows:
        ```text
        +---+---+---+---+---+
        |   |   |   |   |   |
        +---+---+---+---+---+
        |   |   |   |(X)|   |
        +---+---+---+---+---+
        |   |   |(X)| O |   |
        +---+---+---+---+---+
        |   |(X)| X | O |   |
        +---+---+---+---+---+
        |(X)| O | O | O | X |
        +---+---+---+---+---+
    ```

    ----------------------------------------------------------------------------

    Args:
        board (list[list[str]]): A column-major list of the tokens to render.
        winner (set[tuple[int, int]] | None): A set of row/column pairs marking\
            the winning cells of the board. Each tuple should be a (row, col)\
            pair, where the `row` and `col` are the respective values **in the\
            list, not render**. If there is no winner, this should be `None`.

    Exceptions:
        Asserts if the size of the board is not at least 4.

    Errata:
        Previously transposed (R, C) when checking for membership in the
        `winner`
    """
    size = len(board)  # Make sure length makes sense...
    assert size >= 4, f"The board size must be >= 4, not {size}"

    # Make winner an empty set it if was None
    if not isinstance(winner, set):
        winner = set[tuple[int, int]]()

    for R in range(size - 1, -1, -1):  # Rows (for printing)
        print("    ", "+---" * size, "+", sep="")

        print("    ", end="")
        for C in range(size):  # Columns (for printing)
            if R < len(board[C]):  # Check if there's really data
                # Note that `C` is first; column-major order!
                token = board[C][R]

                # Note that `(C, R)` is about the list itself, not the render!
                # Errata: Previously transposed to (R, C) which wouldn't
                #   preform the operations as described.
                if winner.issuperset(((C, R),)):
                    print(f"|({token:1})", end="")  # Winner!
                else:
                    print(f"|{token:^3}", end="")

            else:  # Jagged; assume blank
                print("|   ", end="")
        print("|")
    print("    ", "+---" * size, "+", sep="")


def mark_winner(player: int, cells: set[tuple[int, int]] | None) -> None:
    """A special function for the Ag to know who won a match. If no one won as
    there was a tie, you should indicate player `0` won and provide an empty
    set.

    For your code, this doesn't do anything, but it will have special meaning to
    the Ag. You do not need to write any code for this function.

    Args:
        player (int): The player who won; either `1` or `2`. If no one won,\
            this should be `0`.
        cells (set[tuple[int, int]] | None): The cells that caused the win, as\
            a set of (row, col) pairs into the list, not the rendered board. If
            no one won, this should be `None`.
    """
    pass


def get_board_size():
    while True:
        size = input("Enter board size (at least 4 or hit enter for default 7): ")
        if size == "":
            return 7
        try:
            size = int(size)
            if size >= 4:
                return size
            else:
                print("Size must be at least 4.")
        except ValueError:
            print("Invalid input, please enter a valid integer.")

def get_player_move(board, player):
    while True:
        if player == 1:
            token = "X"
        else:
            token = "O"
        prompt = "Player " + str(player) + " ('" + token + "'), choose column (0 to " + str(len(board) - 1) + "): "
        try:
            column = int(input(prompt))
            if 0 <= column < len(board) and len(board[column]) < len(board):
                return column
            else:
                print("Invalid column or column is full. Try again.")
        except ValueError:
            print("Invalid input, please enter a valid integer.")

def add_token(board, column, token):
    board[column].append(token)
    if check_win(board, column, token):
        return True
    return False

def check_win(board, column, token):
    # Placeholder for win check logic
    return False  # This should contain the actual implementation

def connect_four():
    size = get_board_size()
    board = []
    for _ in range(size):
        board.append([])
    player = 1
    game_over = False

    while not game_over:
        column = get_player_move(board, player)
        if player == 1:
            token = "X"
        else:
            token = "O"
        if add_token(board, column, token):
            mark_winner(player, set())  # Pass actual winning cells
            render(board, None)  # Placeholder for actual winning cells
            print("Congratulations Player " + str(player) + " ('" + token + "'), you win!")
            game_over = True
        else:
            if player == 1:
                player = 2
            else:
                player = 1

        # No winner yet, render the board for the next player's turn
        render(board, None)

def main():
    connect_four()

if __name__ == "__main__":
    main()